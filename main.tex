\documentclass[9pt,b5paper,tombo]{jsbook}

\usepackage[dvipdfmx]{graphicx}
\usepackage{listings}
\usepackage{color}

\lstset{basicstyle={\footnotesize\ttfamily}}

\setlength{\textwidth}{\fullwidth}
\setlength{\evensidemargin}{\oddsidemargin}

\begin{document}

\enlargethispage{\paperwidth}
\thispagestyle{empty}
\vspace*{-1truein}
\vspace*{-\topmargin}
\vspace*{-\headheight}
\vspace*{-\headsep}
\vspace*{-\topskip}
\noindent\hspace*{-1in}\hspace*{-\oddsidemargin}
%\includegraphics[width=\paperwidth]{./img/cover.pdf}

\newpage

\thispagestyle{empty}
%\setlength{\textwidth}{\fullwidth}
%\setlength{\evensidemargin}{\oddsidemargin}

\tableofcontents

\newpage

\thispagestyle{empty}

\vspace*{\stretch{1}}

\chapter{はじめに}

\setcounter{page}{1}

\chapter{KVM}

KVMについて知りたい人がいたとして、その人が知りたいのは恐らくKVMではなくQEMUだろう。この章では、実はKVMは、特に何もしていない、というのを解説しようと思う。メモリの割り当て？ネットワーク接続？USB?ディスク？それはKVMではなくQEMUで語るものだ。皆が何となく「ハイパーバイザ」と呼ぶ物、それは正確には「仮想マシン」と呼び、それはQEMUによって実現される。KVMはQEMUの仮想CPU高速化モジュールとしてとらえてしまっても、特に誤解はない。そして、これを正確には「ハイパーバイザ」と呼ぶ。

KVMとQEMUの違いをはっきりさせないと、有らぬ誤解を生むばかりか、適切な情報を検索することもままならない。この2つは似て非なるものではなく、はっきり言って、特に依存はない。KVMが無くてもQEMUは動く。実はKVMなんて影も形もない頃から、QEMUは比較的安定して動作していた。あえて言ってしまうと、むしろKVMの方が、存在意義という観点から、QEMUに依存している。

勉強し始めた時、僕はまずKVMから勉強を始めた。そこからvhostやvirtioをいったものを調べ始めた。が、どうしてもよく分からない。最近ようやく理解のとっかかりをつかみ始めたが、ここに至ってようやく、最初からQEMUを勉強しておけば迷いにくいことに気付いた。というわけで、この本ではQEMUの解説からしていくことにする。

\section{QEMU}

フォン・ノイマンという人が提唱したノイマン型コンピュータの仕組みは、何の改善もないまま、現在のコンピュータに使われている。基本的には、こうだ。コンピュータは以下の要素で成り立つ

\begin{itemize}
  \item 演算装置（CPU）
  \item 記憶装置（RAM, Disk）
  \item 出力装置（Tape, Display）
  \item 入力装置（マウス・キーボード）
\end{itemize}

記憶装置に書き込まれたプログラム通りに、記憶装置に一時的な計算結果を書き込みつつ、演算装置が計算を行う。可変パラメータは入力装置から得られるし、計算結果は出力装置に送られる。言ってしまえば、コンピュータはこれだけのことしかしない。CPUにはレジスタもある、という反論もあるが、それは要するに記憶装置だ。ネットは？それはよく訓練された入出力装置に過ぎない。まとめてしまえばたったこれだけでコンピュータは動作する。

そして、驚くべきことに、QEMUを知る上での前提知識は以上だ。QEMUとは、つまりこの各装置をソフトウェアでエミュレートしているだけなのだ。

\subsection{CPUのエミュレート}

KVMの話をする時に必要になるのが、CPUの仮想化だ。CPUが解釈できる様々な演算命令をすべてエミュレートすれば、CPUの仮想化ができる。QEMUは様々なCPUの命令をエミュレートできる。ARMもx86も認識できる。

中でやっていることは単純だ。実行するべき命令をホストのCPU命令に書き換えて実行する。x86のCPUで動作するホストでARMの命令をエミュレートするには、ARMの命令をx86の命令に変換すればよい。CPUでできることなどたかがしれているから、ほぼ一対一で対応がある。対応がない場合は、複数の命令を組み合わせて代替する。

で、問題はx86の命令をエミュレートしてx86の命令に書き換える時だ。これはエミュレートする必要がない。直接ホストのx86の命令を実行すればよい。双方同じCPUモデルなのだから、同じ命令がそのまま実行できるはずだ。そっちの方が変換の手間がなくなるから実行が高速になるが、それ以前に、そもそも無駄だ。

のだが、ここで問題が起きる。実は、そのまま実行できない命令があるのだ。これはCPUが悪いのでも、QEMUのエミュレートが悪いわけでもない。実行できないのは、OSが実行を制限してしまうからだ。

\subsection{リングプロテクション}

実はすべてのCPU命令をユーザーが実行できるわけではない。OSしか実行できないような強力なコマンドは、OSのユーザーは実行することができない。これをOSの「リングプロテクション」と言い、これら特別な命令群を「Ring 0」とか「センシティブな命令」と読んだりするが、要するにOSのような特別な奴にしか実行が許されていない命令群があるのだ。Linuxで言うならば、カーネル空間でしか実行できない命令群である。

ここで常に念頭において置かねばならないが、当たり前で忘れがちなことがある。それは、エミュレーターであるQEMUは「ユーザー空間のプログラムである」ということである。QEMUがユーザー空間で動作するソフトウェアであることが、脈々と発展し続けるKVM開発の原動力となる。すべての周辺技術はこの当たり前の事実との戦いの歴史である。

つまり、確かにQEMUはx86の命令をすべて解釈し実行できる能力はあるが、センシティブな命令はQEMUが動作しているOSにより実行が禁止される。つまり、実行できない。実行しようとした場合はどうなるか分からない。普通なら、強制的にKillされるだろう。ホストから見れば、完全に「悪意のあるプログラム」にしか見えないからだ。

センシティブな命令を実行するには、システムコールを使うか別のセンシティブでない命令群で置き換えるかしなければならない。さて、今QEMUは命令をホストのCPUで直接実行している。センシティブな命令が実行されようとしていることを知るにはどうすれば？この瞬間をQEMUがキャッチできなければ、QEMUはプロセスごとKillされることになる。

長かったが、ここでKVMが現れる準備が整ったことになる。

\section{KVM}

さて、前章をもってすればKVMの解説は単純を極める。KVMとは、センシティブな命令が実行されようとすしていることを、ユーザー空間のプログラムに教える機能を持つ、カーネルモジュールである。知りたいユーザー空間のプログラムは/dev/kvmをポーリングしていると、KVMが教えてくれる。KVMはそれしかしない。今のKVMはいかに「本当にそれだけのことをする」ように機能を削り、磨かれているところである。

\subsection{OpenStack}

\begin{itemize}
  \item KVM
  \item OpenStack
\end{itemize}


\begin{enumerate}
  \item KVM
  \item Docker
  \item LXC
\end{enumerate}

\begin{lstlisting}
./stack.sh
\end{lstlisting}

\chapter{Containers超入門}

\section{Containersの世界とLXC、そしてDocker}

\subsection{昔からあるコンテナ技術}
コンテナ技術を取り囲む現在の状況と、それを踏まえた上でのLXCとDockerの根本的な違いについて説明したいと思う。Linux Containers(LXC)は、どうやって我々がアプリケーションを動かしスケールさせるかという問題を変化させる可能性を持っている。コンテナ技術は新しいものではない。そして、LXCに関して言うと、追加パッチをLinux Kernelに適用させることなく、vanilla Linux Kernel上で稼働させることができる。なお、LXCのVersion1は、長期サポートバージョンであり、5年間サポートされることになる。話が逸れるが、vanilla Linux Kernelとは、Linux作者のLinus Torvalds氏がリリースするプレーンなKernelのことである。それをベースに様々なベンダーが追加で拡張していくのである。また、vanillaという言葉には「普通の、ありきたりな、おもしろみのない」という意味がある。

\noindent
話を戻そう。

コンテナ技術は、最近登場した新技術ではない。昔から存在し色んな所で採用されている。FreeBSDにはJailがあり、SolarisにはZoneがある。それに加えて、OpenVZやLinux VServerのようなContainersも存在する。その歴史は、chrootに始まり、FreeBSD Jailを経て、Linux Containers(LXC)に至る。chrootでは、大雑把に言って、ディレクトリーツリーの分離を行っていた。プロセスリスト自体は共有するようなモデルである。chrootのユースケースとしては、開発者向けのテスト/ビルド用環境である。FreeBSD Jailでは、chrootの機能に加えて、プロセスリストとネットワークスタックも分離(というか隔離)された。ユースケースとしては、root権限の一般ユーザへの委譲、またそれに頼る形でのホスティングサービスである。LXCでは、リソース管理テーブルを隔離し、cgroupsによるシステムリソース(CPU、メモリ、ディスクetc)の制御を行えるようになった。これにより、LXCは、軽量な仮想環境と見なすことができるようになった。

\newpage

\subsection{なぜ皆コンテナに騒いでいるのか}
コンテナは、ホストシステムからアプリケーションのワークロードを隔離、あるいはカプセル化する。コンテナを、ホストOS内にあるアプリケーションが実行されているOSと見なすことができ、かつ、それはVirtual Machineのように振る舞うのである。このエミュレーションは、Linux Kernelそれ自体と、様々なディストリビューションとコンテナを使ってアプリケーションを動かすユーザのためにコンテナ用OSのテンプレートを提供するLXC Projectによって、実現されている。このように、Containers技術が仮想マシンのように振る舞うことが可能になったことが、一気に注目を浴びる原因となったのである。

\subsection{コンテナの価値は?}
コンテナは、アプリケーションをホストOSから分離、抽象化することで、LXCをまたぐシステム間でのポータビリティをもたらす。また、コンテナは、ハードウェアをエミュレートすることなく、cgroupsとnamespacesを駆使してLinux Kernel内でベアメタルに近いスピードの軽量なOS環境を実現している。シンプルで高速、かつハードウェアの仮想化よりもよりポータビリティーがありスケールしやすいという構造により、コンテナは、根本的なユーザのワークロードやアプリケーションの仮想化の方法を変えるものなのである。なお、ここでいうポータビリティーとはDockerによりもたらされる、どこでも同一のアプリケーションを稼働することができるという意味ではない。

\subsection{LXC}
LXCプロジェクトは、コンテナ用のOSテンプレートとライフサイクル管理のための幅広いツールセットを提供しています。現在、Canonicalのサポートのもと、Stephane GraberとSerge Hallynにより開発は主導されています。

LXCは、活発に開発されているがその割にはドキュメントが少ない。特にUbuntu以外のディストリビューションで利用する際のドキュメントが欠如しており、多くの機能はまずUbuntu上で実装される。他のディストリビューションを利用しているユーザーからしたら、とてもフラストレーションのたまることである。また、ネット上には数多くの誤解を招くような情報があふれ、混乱を招いている状況も少なからずある。広くマーケットで存在感を示しているDockerと混同されたり、そもそもの情報の多さが混乱の元となっていたりする。

LXCは、Dockerのようなフロントエンドのアプリケーションのためのローレイヤー層なのか、はたまた、DockerがLXC上に構築されたユーザーフレンドリーなフロントエンドなのか？こういった不確かな情報が広く出回っている。コンテナ技術のメリットを享受するために必ずしもDockerを使う必要はない。Dockerはコンテナ利用の一つの選択でしかないのである。

\subsection{DockerとLXCでは何が違うのか}
Docker視点から見たLXCとの違いについて説明する。
そもそもLXCに対してDockerが提供している機能とは何なのか。まず第一に言われることは、どのようなホストOSであってもポータブルなデプロイが可能である点である。Dockerはアプリケーションをビルドするためのフォーマットが定義されている。この定義をまとめて記述するためにDockerfileファイルを利用する。このDockerfileファイルはビルドでよく使われるmakefileファイル同様にDocker Containersの構成情報をまとめて記述するテキストファイルである。このファイルに記述する定義情報が全ての依存関係をカプセル化しているため、それはどこで実行してもアプリケーション実行環境が同一になるのです。LXCのプロセスのサンドボックスもポータビリティーを持っているが、もしLXCのコンフィグをカスタマイズしているとしたら、ネットワークやストレージ、ディストリビューションの違いにより、それは別環境で稼働しない可能性が高くなります。Dockerはその全てを抽象化するためどんな環境でも稼働させることができるのである。

Dockerについて言及するエンジニアは、総じてアプリケーション寄りのエンジニアである。Dockerは、軽量な仮想マシンとしての利用というよりもアプリケーションのデプロイに最適化されている。これはDocker自体のAPIやデザインの設計思想に反映されている。それとは対照的に、LXCは軽量な仮想マシンとしての利用に注力している。Dockerには、gitに似たバージョン管理機能が含まれている。バージョン間のdiffの取得やCommit、ロールバックが可能となっている。それによって、Containersの変更を誰がどのように行ったのかについての全てのログを追うことができる。

他にもDockerの利点は多く存在するが、主にこのような点により、Dockerは、コンテナそのもの対する見方を変えるきっかけを作った。今まで軽量な仮想マシンとして見られていたコンテナ技術をアプリケーションとしてのコンテナとしてエンジニアに再認識させることに成功したのである。

\newpage

\section{LXCを使い軽量仮想環境を手に入れよう}
LXCの基本的なコマンドを使ったコンテナ操作を，Ubuntu14.04をベースにした環境を使って説明していきたい。

\subsection{LXCのインストール}
Ubuntuの最新版であるUbuntu 14.04 LTSでは、LXC 1.0.7がlxcというパッケージ名で提供されている。また、Debian 8 (Jessie) では、LXC 1.0.6のパッケージが提供されている。

\noindent
インストールは以下のコマンドを叩くだけである。

\begin{lstlisting}
$ sudo apt-get install lxc
\end{lstlisting}

\subsection{LXCで仮想環境を立ち上げる}
LXCによる仮想環境を立ち上げるためには、まずテンプレートと呼ばれる設定ファイルを用いる。デフォルトでメジャーディストリビューションのテンプレートはすでに同梱されているためこちらを利用する。テンプレートは/usr/share/lxc/templatesに配置されている。

\begin{lstlisting}
$ ls /usr/share/lxc/templates/
lxc-alpine    lxc-archlinux  lxc-centos  lxc-debian    lxc-fedora  lxc-openmandriva  lxc-oracle  lxc-sshd    lxc-ubuntu-cloud
lxc-altlinux  lxc-busybox    lxc-cirros  lxc-download  lxc-gentoo  lxc-opensuse      lxc-plamo	 lxc-ubuntu
\end{lstlisting}

\noindent
Ubuntuのテンプレートを用いてtest-container-101という名前のUbuntuのコンテナを立ち上げる。

\begin{lstlisting}
$ sudo lxc-create -t ubuntu -n test-container-101
\end{lstlisting}

\noindent
これでコンテナのrootディレクトリに相当するディレクトリに必要なものがインストールされる。コンテナの場所は以下のディレクトリである。

\begin{lstlisting}
/var/lib/lxc/<コンテナ名>/
\end{lstlisting}

\noindent
そこで、test-container-101のrootfsの中を覗いてみると以下の通りとなる。

\begin{lstlisting}
$ sudo ls -F /var/lib/lxc/test-container-101/rootfs/
bin/  boot/  dev/  etc/  home/	lib/  lib64/  media/  mnt/
opt/  proc/  root/	run/  sbin/  srv/  sys/  tmp/  usr/  var/
\end{lstlisting}

\newpage

\noindent
インストールしたコンテナの起動には以下のコマンドを実行する。

\begin{lstlisting}
$ sudo lxc-start -n test-container-101 -d
\end{lstlisting}

\noindent
-dオプションでデーモンとしてコンテナを起動する。この状態でlxc-consoleコマンドを用いてコンソール接続することでコンテナの内部にログインすることができる。

\begin{lstlisting}
$ sudo lxc-console -n test-container-101
\end{lstlisting}

\noindent
コンテナから抜ける際には、Ctrl+Aを入力してその後Qを押す。また、デフォルトのユーザはubuntuで、パスワードもubuntuである。インストール時に以下のメッセージが表示されているはずである。

\begin{lstlisting}
# The default user is 'ubuntu' with password 'ubuntu'!
# Use the 'sudo' command to run tasks as root in the container.
\end{lstlisting}

\noindent
コンテナの終了は、lxc-shutdownコマンドを実行すればよい。

\begin{lstlisting}
$ sudo lxc-shutdown -n test-container-101
\end{lstlisting}


\subsection{コンテナの情報を見る}
コンテナに関する情報を見てみよう。lxc-lsというコマンドでホスト上にあるコンテナの情報を確認することができる。--fancyオプションを付けることで、コンテナ名、状態、IPv4のアドレス、IPv6のアドレス、自動起動の有無を確認できる。

\begin{lstlisting}
$ sudo lxc-ls --fancy
NAME                STATE    IPV4  IPV6  AUTOSTART
--------------------------------------------------
test-container-101  STOPPED  -     -     NO
\end{lstlisting}

\noindent
コンテナ単体の詳細情報についてはlxc-infoというコマンドが提供されている。コンテナがSTOPPEDした状態のときにはこう表示される。

\begin{lstlisting}
$ sudo lxc-info -n test-container-101
Name:           test-container-101
State:          STOPPED
\end{lstlisting}

\noindent
コンテナを起動すると詳細情報が表示される。

\begin{lstlisting}
$ sudo lxc-info -n test-container-101
Name:           test-container-101
State:          RUNNING
PID:            20434
CPU use:        0.77 seconds
BlkIO use:      7.16 MiB
Memory use:     13.53 MiB
KMem use:       0 bytes
Link:           vethABI04E
 TX bytes:      940 bytes
 RX bytes:      592 bytes
 Total bytes:   1.50 KiB
\end{lstlisting}


\noindent
このように特定の情報のみを取得することも可能である。

\begin{lstlisting}
$ sudo lxc-info -n test-container-101 -c lxc.utsname -c lxc.rootfs
lxc.utsname = test-container-101
lxc.rootfs = /var/lib/lxc/test-container-101/rootfs
\end{lstlisting}

\newpage

\subsection{LXDとは何か}
LXDについて本家ページを元に少し説明する。LXDとはLinux Container Daemonの略である。Canonical主導で開発が進められているコンテナ技術であり、コンテナに今どきのハイパーバイザーの機能を追加するサーバプログラムである。このデーモンはREST APIを提供しているのでローカルからだけでなくネットワーク経由でのコンテナの操作が可能である。
\noindent
主要機能は以下の通りである。
\begin{itemize}
  \item 非特権コンテナ、リソース制限を用いたセキュアなデザイン
  \item 直感的なコマンドラインとREST API
  \item イメージベースのコンテナ構築
  \item ライブマイグレーション
\end{itemize}

\noindent
特に、Docker Hubにあるイメージを利用可能になるということがアナウンスされている点が期待できる。


\subsection{LXDインストール}
UbuntuユーザはPPAを使って以下の通りインストール可能である。なお、他のディストリビューションのユーザは、最新のリリースのtarballかgitリポジトリから直接LXDをダウンロードしてビルドできる。
\begin{lstlisting}
$ sudo add-apt-repository ppa:ubuntu-lxc/lxd-git-master
$ sudo apt-get update && sudo apt-get -y install lxd
\end{lstlisting}

\subsection{LXDイメージのインポート}
イメージベースなので、ダウンロードする。なお、LXDのコマンドラインはlxcというコマンドである。何ともややこしい。コンテナイメージのインポートはlxc-imagesというコマンドを利用する。以下では、Ubuntu14.04をインポートしている。

\begin{lstlisting}
$ sudo lxd-images import lxc ubuntu trusty amd64 --alias ubuntu
\end{lstlisting}

\noindent
以下のコマンドでイメージ一覧を取得できる。
\begin{lstlisting}
$ sudo lxc image list
+--------+--------------+--------+-------------+--------+------------------------------+
| ALIAS  | FINGERPRINT  | PUBLIC | DESCRIPTION |  ARCH  |         UPLOAD DATE          |
+--------+--------------+--------+-------------+--------+------------------------------+
| ubuntu | 04aac4257341 | no     |             | x86_64 | Jul 15, 2015 at 1:16pm (UTC) |
+--------+--------------+--------+-------------+--------+------------------------------+
\end{lstlisting}

\newpage

\subsection{LXDコンテナの起動}
lxc launchコマンドで起動できる。
\begin{lstlisting}
$ sudo lxc launch ubuntu test-container-102
Creating container...done
Starting container...done
error: saving config file for the container failed
\end{lstlisting}

\noindent
できなかった。。。。どうやらこのバグにヒットしたらしい。(https://github.com/lxc/lxd/issues/739)

\noindent
改めて起動するとこのようになる。
\begin{lstlisting}
$ lxc list
+--------------------+---------+------------+------+-----------+-----------+
|        NAME        |  STATE  |    IPV4    | IPV6 | EPHEMERAL | SNAPSHOTS |
+--------------------+---------+------------+------+-----------+-----------+
| test-container-103 | RUNNING | 10.0.3.138 |      | NO        | 0         |
+--------------------+---------+------------+------+-----------+-----------+
\end{lstlisting}

\noindent
このような感じでLXDを扱えるが、まだまだバグもあり不安定だという印象が強い。もし、興味があれば使ってみてほしい。

\chapter{あとがき}

\section{こじろー}
本体は表紙です。ついでに、中身も流し読みしていただけると嬉しいです。

\section{まっきー}

hogehoge

\section{だーまり}

hogehoge

\newpage

%\setlength{\textwidth}{\fullwidth}
%\setlength{\evensidemargin}{\oddsidemargin}

\enlargethispage{\paperwidth}
\thispagestyle{empty}
\vspace*{-1truein}
\vspace*{-\topmargin}
\vspace*{-\headheight}
\vspace*{-\headsep}
\vspace*{-\topskip}
\noindent\hspace*{-1in}\hspace*{-\oddsidemargin}
%\includegraphics[width=\paperwidth]{./img/bcover.pdf}

\end{document}
